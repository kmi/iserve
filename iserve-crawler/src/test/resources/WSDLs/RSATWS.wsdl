<?xml version="1.0" encoding ='UTF-8' ?>
<?xml-stylesheet type="text/xsl" href="RSATWS.xsl"?>
<definitions name="RSATWS"
	     targetNamespace="urn:RSATWS"
             xmlns:tns="urn:RSATWS"
             xmlns:xsd="http://www.w3.org/2001/XMLSchema"
             xmlns="http://schemas.xmlsoap.org/wsdl/"
	     xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
	     xmlns:html="http://www.w3.org/1999/xhtml"
	     xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

  <types>
    <xsd:schema targetNamespace="urn:RSATWS" xmlns="http://www.w3.org/2001/XMLSchema" xmlns:xsd="http://www.w3.org/2001/XMLSchema">

      <!-- RSA TOOLS REQUESTS -->
      <xsd:complexType name="RetrieveSequenceRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation retrieve_seq.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="organism" type="xsd:string" minOccurs="1">
            <xsd:annotation>
              <xsd:documentation>Organism. Words need to be underscore separated (example: Escherichia_coli_K12).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="query" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>A list of query genes.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="all" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Return sequences for all the genes of the organism if value = 1. Incompatible with query.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="noorf" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Prevent overlap with upstream open reading frames (ORF) if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="from" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Inferior limit of the region to retrieve.
Default is organism dependant (example: Saccharomyces cerevisiae = -800).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="to" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Superior limit of the region to retrieve. Default is '-1'.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="feattype" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Type of genome features to load. Supported: CDS, mRNA, tRNA, rRNA. </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="type" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation> Sequence type. Supported: upstream, downstream, ORF (unspliced open reading frame).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Sequence format. Supported: IG (Intelligenetics), WC (wconsensus), raw, FastA</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="lw" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Line width (0 for whole sequence on one line).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="label" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Field(s) to be used in the sequence label. Multiple fields can be specified, separated by commas. 
Supported: id, name, organism_name, sequence_type, current_from, current_to, ctg, orf_strand, reg_left, reg_right. 
Default: name.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="label_sep" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Separator between the label fields. Default: | (pipe character).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="nocom" type="xsd:int" minOccurs="0">
           <xsd:annotation>
              <xsd:documentation>No comments if value = 1. Only the identifier and the sequence are returned. 
By default, the comment indicates the ORF and upstream sequence coordinates.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="repeat" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Use the repeat masked version of the genome if value = 1.
Warning: repeated regions are annotated for some genomes only.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="imp_pos" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Admit imprecise positions if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RetrieveSequenceMultigenomeRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation retrieve_seq_multigenome.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="input" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>The input file is a tab-delimited text files with (at least) the two following columns:
    1. gene ID or name
      Identifier oor synonyms are supported.
    2. Organism name
      For the organism name, spaces must be replaced by underscore character
      (exactly as for retrieve-seq).
    If additional columns are included in the input file, they are ignored.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="tmp_input_file" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Input file on the server.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="all" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Return sequences for all the genes of the organism if value = 1. Incompatible with query.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="noorf" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Prevent overlap with upstream open reading frames (ORF) if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="from" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Inferior limit of the region to retrieve. Default is organism dependant (example: Saccharomyces cerevisiae = -800).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="to" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Superior limit of the region to retrieve. Default is '-1'.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="feattype" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Type of genome features to load. Supported: CDS, mRNA, tRNA, rRNA. </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="type" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation> Sequence type. Supported: upstream, downstream, ORF (unspliced open reading frame).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Sequence format. Supported: IG (Intelligenetics), WC (wconsensus), raw, FastA</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="lw" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Line width (0 for whole sequence on one line).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="label" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Field(s) to be used in the sequence label. Multiple fields can be specified, separated by commas. 
Supported: id, name, organism_name, sequence_type, current_from, current_to, ctg, orf_strand, reg_left, reg_right. 
Default: name.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="label_sep" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Separator between the label fields. Default: | (pipe character).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="nocom" type="xsd:int" minOccurs="0">
           <xsd:annotation>
              <xsd:documentation>No comments if value = 1. Only the identifier and the sequence are returned. 
By default, the comment indicates the ORF and upstream sequence coordinates.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="repeat" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Use the repeat masked version of the genome if value = 1. Attention: repeated regions are annotated for some genomes only.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="imp_pos" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Admit imprecise positions if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="gene_col" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Number of the column containing the gene names/identifiers (default: 1).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="org_col" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Number of the column containing the organisms (default: 2).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RetrieveEnsemblSequenceRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation retrieve_ensembl_seq.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="organism" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Organism. Words need to be underscore separated (example: Escherichia_coli_K12).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="ensembl_host" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Address of ensembl database server (default is EBI server).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="db_name" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Name of EnsEMBL database (alternative to organism).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="query" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>A list of query genes. You need to supply either this parameter or the next one (tmp_infile).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation> Name of the file with list of genes on the server. You need to supply either this parameter or the previous one (query).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="all" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Return sequences for all the genes of the organism if value = 1. Incompatible with query.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="noorf" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Prevent overlap with upstream open reading frames (ORF) if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="nogene" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Prevent overlap with upstream gene (extreme transcripts limits) if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="from" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Inferior limit of the region to retrieve. Default is organism dependant (example: Saccharomyces cerevisiae = -800).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="to" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Superior limit of the region to retrieve. Default is '-1'.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="feattype" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Type of genome features to load. Supported: Gene, CDS, mRNA, intron, exon. </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="type" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation> Sequence type. Supported: upstream, downstream.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="chromosome" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Chromosome name or number (to use with -left and -right).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="left" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Left limit of sequence to retrieve.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="right" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Right limit of sequence to retrieve.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="strand" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Strand of sequence to retrieve when using -left and -right. Values: 1, -1</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="features" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Features.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="feat_format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Features format. Supported: ft, gft</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="mask_coding" type="xsd:int" minOccurs="0">
           <xsd:annotation>
              <xsd:documentation>All coding sequence is replaced by N in the retrieved sequence if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="repeat" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Use the repeat masked version of the genome if value = 1. Attention: repeated regions are annotated for some genomes only.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="all_transcripts" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Get sequences for all transcript of genes if value = 1. Combine with unique_sequences option if you do pattern discovery afterwards.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="unique_sequences" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>When getting sequences for all transcripts of genes, keep only non-redundant fragments if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="first_intron" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>With feattype intron, get only first intron sequence if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="non_coding" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>With feattype exon, get only non-coding (part of) exons if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="utr" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>With feattype UTR, get only 5prime or 3prime UTR (default is all UTRs).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="line_width" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>A newline character will be inserted in the sequence every ## bases. 0 will prevent newline insertion. This is the default value</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="ortho" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Get orthologuous sequences if value = 1.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="taxon" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Filter on taxonomic level when collecting orthologs (e.g. Murinae)</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="homology_type" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Filter on homology type when collecting orthologs (e.g. ortholog_one2one)</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="header_organism" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Type of organism name to use in the fasta header (scientific, common or none).
 Default is scientific. Common name is only accessible with -ortho.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="PurgeSequenceRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation purge_sequence.</xsd:documentation>
        </xsd:annotation>
       <xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sequence" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Sequence to purge. You need to supply either this parameter or the next one (tmp_infile).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation> Name of the file with input sequence on the server. You need to supply either this parameter or the previous one (sequence).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="format" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Sequence format. Supported: IG (Intelligenetics), WC (wconsensus), raw, FastA.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="match_length" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Minimal match length. Default is 40.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="mismatch" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of mismatches allowed. Default is 3.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="str" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Discard duplications on the direct strand only (1) or on the reverse complement as well (2). Default is 2.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="delete" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Delete repeats instead of masking them if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="mask_short" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Mask (replace by N characters) sequences shorter than the specified length.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
       </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="OligoAnalysisRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation oligo_analysis.</xsd:documentation>
        </xsd:annotation>
       	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="verbosity" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Verbosity.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sequence" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input sequence. You need to supply either this parameter or the next one (tmp_infile).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Name of the file with input sequence on the server. You need to supply either this parameter or the previous one (sequence).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="format" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input sequence format. Supported: IG (Intelligenetics), WC (wconsensus), raw, fasta. Default is fasta.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="length" type="xsd:int" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Oligomer length.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="organism" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Organism. Words need to be underscore separated (example: Escherichia_coli_K12).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Background model: Type of sequences used as background model for estimating expected oligonucleotide frequencies. 
Supported: upstream, upstream-noorf, upstream-noorf-rm, intergenic, input.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="stats" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>List of statistics to return. Supported:occ, mseq, freq, proba, ratio, zscore, like, pos, rank.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="noov" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>No overlapping of oligos allowed if value = 1.
Disable the detection of overlapping matches for self-overlapping patterns (ex TATATA, GATAGA).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="str" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Oligonucleotide occurrences found on both stands are summed (2) or not (1). Default is 2.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sort" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Sort oligomers according to overrepresentation if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="lth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>Lower threshold on some parameters. Format=list of'parameter value'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="uth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>Upper threshold on some parameters. Format=list of 'parameter value'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="pseudo" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Pseudo-weight. Must be a real value between 0 and 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="DyadAnalysisRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation dyad_analysis.</xsd:documentation>
        </xsd:annotation>
       	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="verbosity" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Verbosity.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sequence" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input sequence. You need to supply either this parameter or the next one (tmp_infile).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Name of the file with input sequence on the server. 
You need to supply either this parameter or the previous one (sequence).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="format" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input sequence format. Supported: IG (Intelligenetics), WC (wconsensus), raw, fasta. Default is fasta.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="length" type="xsd:int" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Dyad length.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="spacing" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Spacing between elements of the dyads.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="organism" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Organism. Words need to be underscore separated (example: Escherichia_coli_K12).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Background model: Type of sequences used as background model for estimating expected oligonucleotide frequencies. 
Supported: upstream, upstreamL, upstream-noorf, intergenic, input.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="stats" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>List of statistics to return. Supported: occ, mseq, freq, proba, ratio, zscore, like, pos, rank.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="type" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>dyad_type (dr | ir | rep | any) 
In order to fasten execution, the program can be asked to restrict its analysis to symmetric dyads. 
Four types are accepted: 
	dr - direct repeats: the second element is the same as the first one; 
	ir - inverted repeats: the second element is the revers complement of the first one; 
	rep - repeats: direct and inverted repeats are evaluated. 
	any - (default) 
When selecting the option any, the analysis is performed on all non-symmetric dyads as well.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="noov" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>No overlapping of dyads allowed if value = 1. 
Disable the detection of overlapping matches for self-overlapping patterns (ex TATATA, GATAGA).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="str" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Dyad occurrences found on both stands are summed (2) or not (1). Default is 2.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sort" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Sort dyads according to overrepresentation if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="under" type="xsd:int" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Detect under-represented instead of over-represented dyads (left tail significance test) if value = 1.</xsd:documentation>
	  </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="two_tails" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Detect under-represented and over-represented dyads (two-fail significance test) if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="zeroocc" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Report also dyads with zero occurrences (provided they fit the other thresholds) if value = 1. 
By default, the program reports only patterns present in the sequence. 
If the left tail or two-tail test is applied, patterns with zero occurrences are automatically taken into account. 
In some other cases, one would also like to detect patterns absent from the sequence. 
This is the function of the option -zeroocc.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="lth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>Lower threshold on some parameters. Format=list of 'parameter value'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="uth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>Upper threshold on some parameter. Format=list of 'parameter value'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="PatternAssemblyRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation pattern_assembly.</xsd:documentation>
        </xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="input" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input data</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input file on the server (workflow usage)</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="verbosity" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Verbosity.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="score_col" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Score column. Column of the input file that contains the scores.
If not specified, patterns are incorporated according to their order in the input file.
However, if the input file has been generated with oligo-analysis or dyad-analysis with a verbosity >= 1,
pattern-assembly detects the occ_sig column in the file header and uses this column as score column.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="str" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Strands for the assembly: 1 for single-strand; 2 for two-strand assembly. Default is 2.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="maxfl" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximum flanking segment size. Default is 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="subst" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximum allowed substitutions. Default is 0.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="max_asmb_nb" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximum number of assemblies. Default is 0 (no limit).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="max_asmb_size" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximum assembly size, i.e. number of patterns per assembly. Default is 50.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="maxpat" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximum number of allowed patterns. If the number of patterns exceeds this value, the program issues a fatal error.
Default is 0 (no limit). Not compatible with toppat option.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="toppat" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximum number of patterns to analyze.
If the number of patterns in the input exceeds this value, the assembly is restricted with the top patterns only.
Default: 100. Not compatible with maxpat option.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="DnaPatternRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation dna_pattern.</xsd:documentation>
        </xsd:annotation>
       	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sequence" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input sequence. You need to supply either this parameter or the next one (tmp_infile).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Name of the file with input sequence on the server. You need to supply either this parameter or the previous one (sequence).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="format" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input sequence format. Supported: IG (Intelligenetics), WC (wconsensus), raw, fasta. Default is fasta.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="subst" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of substitutions allowed.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="pattern" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Pattern to match. Use this option or the 'pattern_file' option</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="pattern_file" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>File with patterns to match. Use this option or the 'pattern' option</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_pattern_file" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>File located on the server with patterns to match (workflow usage).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="id" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Pattern identifier.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="origin" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Origin for the calculation of positions (0 for end of sequence).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="noov" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>No overlapping of oligos allowed if value = 1.
Disable the detection of overlapping matches for self-overlapping patterns (ex TATATA, GATAGA).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="score" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Score column. Column of the pattern file which contains the score</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="str" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Oligonucleotide occurrences found on both stands are summed (2) or not (1). Default is 2.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sort" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Sort oligomers according to overrepresentation if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="th" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Threshold on match count.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>List of fields to return. Multiple fields can be entered separated by commas.
Supported fields: colsum,counts,ct,limits,profiles,rank,rowsum,scores,sites,stats,table,total.
    sites: return match positions (default)
    limits: return start and end positions for each input sequence
    counts: return the count of matches per sequence
    rank: return the rank of the sequence (this is especially useful in combination with the option -sort)
    score: return a score per sequence, computed by summing the scores of the matching patterns
    ct: same as '-return counts', except that it returns the sum of matches in all the files of the sequence file list, instead of the count within each separate file
    table: return the count of pattern matches per sequence in the form of a table.  (one line per sequence, one column per pattern)
    colsum: (together with -return table) prints an extra column with the total occurrences per sequence
    rowsum: (together with -return table) prints an extra row with total occurrences per pattern
    total: (together with -return table) prints an extra column with the total occurrences per sequence and 
          an extra row with total occurrences per pattern.  (amounts to combine -colsum and -rowsum)
    stats: return matching statistics
    profiles: return matching profiles with sliding windows.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ConvertFeaturesRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation convert_features.</xsd:documentation>
        </xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="input" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input data</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input file on the server (workflow usage)</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="from" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: dnapat,ft,gft,gff3,gff.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="to" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: dnapat,ft,gft,gff3,gff.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="FeatureMapRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation feature_map.</xsd:documentation>
        </xsd:annotation>
       	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="features" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>a list of features (ORFs, regulatory sites). Each feature is represented by a single line, which should	provide the following information:
Input file columns:
	1. map label (eg gene name)
	2. feature type
	3. feature identifier (ex: GATAbox, Abf1_site)
	4. strand (D for Direct, R for Reverse),
	5. feature start position
	6. feature end position
	7. (optional) description 
	8. (optional) score
The standard input format assumes that these topics are provided in this order, separated by tabs. Start and end positions can be positive or negative.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Name of the file with input features on the server (workflow usage). You need to supply either this parameter or the previous one (features).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sequence" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input sequence(s).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_sequence_file" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Reference sequence file on the server (workflow usage)</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="sequence_format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Format of reference sequence file on the server.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="format" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Output image format. Supported: png,jpg,ps,gif (default = jpg)</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="from" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Lower limit of the positions represented on the graph.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="to" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Upper limit of the positions represented on the graph.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="title" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Generic Title for the feature map.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="label" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Define the info to display for each feature. Valid keys are: id, strand, descr (feature descritption), pos (feature start and end positions).
Several keys can be entered separated by commas without space. ex: -label pos,id. (default = id).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="symbol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Associates a graphical symbol (i.e. rectangle, circle, buterfly, ...) to each feature. This is convenient to distinguish the features on black and white printings.
Mutually exclusive with the -dot option.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="dot" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A color dot is associated to each feature. This allows to distinguish overlapping structures on a color screen. Mutually exclusive with the -symbol option.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="mlen" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>map length (in pixels).Default is 600.Length refers to either height (for vertical maps) of width (for horizontal maps).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="mapthick" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Map thickness.Thickness refers to either width (for vertical maps) or height (horizintal maps). This parameter allows to change the thickness allocated to each map.
This is useful when labels are too large. Default is 150.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="mspacing" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Map spacing.The size of the border between maps (in pixel).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="origin" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>All coordinates are recalculated relative to this origin.This allows to display all coordinates with respect to the ORF start or transcription start site.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="legend" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Draws a legend on the graph, showing the symbol associated to each distinct feature.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="scalebar" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Draws a scale bar on the left of the graph.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="scalestep" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Step between annotations of the scale bar. If not specified, a reasonable step is calculated on basis of the scale bar range.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="scorethick" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Each feature is displayed with a thickness proportional to its score. Only positive scores are represented.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="maxscore" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>(only valid when -scorethick is active) Maximal allowed score value. Higher score values are clipped for the drawing.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="minscore" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>(only valid when -scorethick is active) Minimal allowed score value. Features with smaller score are not displayed.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="maxfthick" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Max feature thickness</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="minfthick" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Min feature thickness</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="htmap" type="xsd:int" minOccurs="0">
            <xsd:annotation>
	      <xsd:documentation>HTML map. An HTML document is automatically generated, which includes the feature map GIF file as an HTML map.
 In other words, this document displays a figure with sensitive areas. Each time the mouse is positioned above a feature, 
information about this particuliar feature is displayed at the bottom of the browser window.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="mono" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Monochrome palette (for printing on black/white printer).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="orientation" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Orientation of the map. Valid values are "horiz" for an horizontal map (default) and "vertic" for a vertical map.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="select" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation> Only display the features whose ID is in the provided id_list.
The id_list contains one or several IDs, separated by commas. IDs may be embraced in single quotes to allow multiple words within the IDs. 
Commas and single quotes are not allowed within an ID.
Example: -select 'gataag','gattag' only displays features identified by gataag or gattag.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="FootprintDiscoveryRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation footprint_discovery.</xsd:documentation>
        </xsd:annotation>
       	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="verbosity" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Level of detail for comments</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="genes" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A list of genes (one by line).
	      </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Name of the file with a list of genes on the server. You need to supply either this parameter or the previous one (genes).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="all_genes" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Automatically analyze all the genes of a query genome, and store each result in a separate folder (the folder name is defined automatically).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="max_genes" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximum number of genes to analyze.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="output_prefix" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Prefix for the output files. If the prefix is not specified, the program can guess a default prefix, but this is working only if there is a single query gene or query file.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="query" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A list of genes (referenced array).
	      </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sep_genes" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Search footprints for each query gene separately. The results arestored in a separate folder for each	gene. The folder name is defined automatically.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="organism" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Query organism, to which the query genes belong.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="taxon" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Reference taxon, in which orthologous genes have to be collected.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="index" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Generate an HTML index with links to the result files.
This option is used for the web interface, but can also be convenient to index results, especially when several genes or taxa are analyzed (options -genes, -all_genes, -all_taxa).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="lth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>Lower threshold on some parameters. Format: parameter value.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="uth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>Upper threshold on some parameters. Format: parameter value.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return fields for dyad-analysis. See dyad_analysis for a list</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="to_matrix" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Convert assembled patterns into position-specific scoring matrices (PSSM).
Caution ! This conversion can take time if the sequence set is large and if there are many assemblies.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="bg_model" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Allow the user to choose among alternative background model.
                                 - taxfreq
                                      Taxon-wide background model, computed by counting dyad frequencies in all the promoters of all the genes of the reference taxon.
                                 - monads
                                      Expected dyad frequencies are the product of monad frequencies observed in the input sequences.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="no_filter" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Accept all dyads, even if they are not found in the promoter of the query gene, in the query organism.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="infer_operons" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Infer operons in order to retrieve the promoters of the predicted operon leader genes rather than those located immediately upstream of the orthologs.
This method uses a threshold on the intergenic distance.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="dist_thr" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Specify here the intergenic distance threshold in base pairs.
Pair of adjacent genes with intergenic distance equal or less than this value are predicted to be within operon. (default : 55).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GetOrthologsRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation get_orthologs.</xsd:documentation>
        </xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="organism" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Organism. Words need to be underscore separated (example: Escherichia_coli_K12).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="taxon" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Reference taxon. Orthologs are returned for each supported organism belonging to the reference taxon.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="query" type="xsd:string" minOccurs="1" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>List of gene(s) for which you want to get orthologs.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="all" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Get orthologs for all the genes of the query organism if value = 1. This option is particularly convenient to extract phylogenetic profiles.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="nogrep" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Disable the pre-filtering with grep if value = 1.
This pre-filtering accelerates the selection of hits, but some grep versions do not support the -E option.
If this is the case on your operating system, you can still obtain the correct results by inactivating the grep filter.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Output field(s).
By default, the output is a two-column file indicating the ID of the gene identified as similar to the query gene, and the name of the reference organism.
The option -return can be used to specify additional output fields.
Supported fields:
       - ref_id: ID of the reference (target) gene
       - ref_organism: Name of the reference (target) organism
       - query_id: ID of the query gene
       - query_organism: Name of the query organism
       - ident: Percent of identity (a number between 0 and 100)
       - ali_len: Alignment lengths (in residues)
       - mismat: Number of mismatches
       - gap_open: Number of gap openings
       - e_value: E-value (expected number of false positives)
       - bit_sc: Bit score
       - rank: Rank
       - s_rank: Source rank (rank of the hit for the query organism).
Several output fields can be entered separated by commas.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="lth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>Lower threshold for dyad-analysis. Format: list of 'parameter value'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="uth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>Upper threshold for dyad-analysis. Format: list of 'parameter value'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="InferOperonRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="organism" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Organism. Words need to be underscore separated (example: Escherichia_coli_K12).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="query" type="xsd:string" minOccurs="1" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>List of gene(s) for which you want to infer the operon.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Name of the file with query genes on the server. You need to supply either this parameter or the previous one (query).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="all" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Infer operons for all the genes of the query organism if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="distance" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Distance threshold.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>List of fields to return.
Supported fields: leader,trailer,operon,query,q_info,up_info,down_info
       - leader: Predicted operon leader.
       - trailer: Predicted operon trailer.
       - operon: Full composition of the operon. The names of member genes are separated by a semi-column ";".
       - q_info: Detailed info on the query gene(s).
       - up_info: Detailed info on the upstream gene.
       - down_info: Detailed info on the downstream gene.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GeneInfoRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="organism" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Organism. Words need to be underscore separated (example: Escherichia_coli_K12).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="query" type="xsd:string" minOccurs="1" maxOccurs="unbounded">
	    <xsd:annotation>
	      <xsd:documentation>List of gene(s) for which you want info on or list of keywords to search for (can be regular expressions).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="full" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Full match only (no substring matching) if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="noquery" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Do not print the query at the begining of each line if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="descr" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Match query against the description, too, not just against gene ID and name if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="feattype" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Feature type (CDS, mRNA, tRNA, rRNA, scRNA).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ClassFreqRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputFile" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Input file</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="classinterval" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>class interval. If not specified, takes the value (max - min)/20</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="col" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>column to which apply the program. This option can be used iteratively.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="min" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>numbers strictly smaller than this value are not taken into account</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="max" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>numbers strictly higher than this value are not taken into account</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="from" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Inferior limit for the classes to display. Values lower than this limit are however taken into account in the calculation of statistics (avg, variance, ...) 
and of class frequencies (In contrast with the -min option).
	      </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="to" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Superior limit for the classes to display. Values higher than this limit are however taken into account in the calculation of statistics (avg, variance, ...) 
and of class frequencies (In contrast with the -min option).
	      </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="XYGraphRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputFile" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>The input file should contain columns with numeric data. Each line contains info about one point of the graph.
By default, the first column is considered to contain X data, and the second column Y data. X and Y columns can be changed with -xcol and -ycol options.
Columns should be separated by tabs.
              </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="format" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Supported : png,pdf,jpg,eps,gif</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="title1" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>first graph title</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="title2" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>second graph title</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="lines" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>points are jointed by lines</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="legend" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Use the content of the first line from input file as legend for Y data.
	      </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="header" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>First line of the data file contains a column header. If option -legend is active, this header is used as legend, else it is ignored.
	      </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="xleg1" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>first x legend</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="xleg2" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>second x legend</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="yleg1" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>first y legend</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="yleg2" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>second y legend</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="xmax" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>maximal value represented on X axis.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="ymax" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>maximal value represented on Y axis.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="xmin" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>minimal value represented on X axis.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="ymin" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>minimal value represented on Y axis.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="ylog" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Y data are displayed on a logarithmic scale. If the next argument is a number, it provides the log base. Default log base is 10.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="xlog" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>X data are displayed on a logarithmic scale. If the next argument is a number, it provides the log base. Default log base is 10.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="xcol" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Column containing data for the X axis.
A zero value indicates that there is no column with X va lues. In this case, X values are ordinal.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="ycol" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Column containing data for the Y axis.
Several columns can be specified by -ycol #,#,#. A range of columns can be specified by -ycol #-#. They have to be separated by commas without spaces.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RocStatsRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputfile" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>The input file</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Column of the input ile containing the score value (default 1).</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="lcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Column of the input file containing the status label (default 2).</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="status" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>This option allows to use different labels as synonyms for the pre-defined status: pos and neg.
It can be useful to rename these labels, for compatibility with other programs.
For example, it your input file contains annotations of "site" and "non-site", you can use it directly as input with the options.
-status site pos -status non-site neg indicates that the label "site" has to be understood as positive, and "non-site" as negative.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="total" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Total number of elements in the universe (neg + pos).
This option allows to manually specify the total number of elements, in case the input file would not contain the complete data set.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
       </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="TextToHtmlRequest">
       <xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputfile" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>The text input file that will be converted in html</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="chunk" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Chunk size (when there are many rows, the program splits the table into several HTML tables, to reduce the waiting time on the browser.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="no_sort" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>make the output HTML table not sortable.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="font" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Use fixed or variable fonts in html. Supported : variable,fixed</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
       </xsd:sequence>
      </xsd:complexType>
      
      <xsd:complexType name="parsepsixmlRequest">
       <xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputfile" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>The psi XML input file that will be converted in a tab file</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="channels" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A list of evidence channels to filter separated by a comma</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="interactor_type" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A list of interactor_type to filter (separated by comas) : protein, 'small molecule'</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="uth" type="xsd:float" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Upper threshold on the value</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="lth" type="xsd:float" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Lower threshold on the value</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
       </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="SupportedOrganismsRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation supported_organisms.</xsd:documentation>
        </xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="return" type="xsd:string" minOccurs="0">
            <xsd:annotation>
	      <xsd:documentation>Return fields. Supported: ID,name,data,last_update,taxonomy,up_from,up_to,genome,seq_format,source.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="format" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: html_list, html_table, array, text, keys, names, sizes, full, tree, html_tree.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="taxon" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Root taxon.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ConvertSeqRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation convert_seq.</xsd:documentation>
        </xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
        <xsd:element name="sequence" type="xsd:string" minOccurs="0">
	 <xsd:annotation>
	  <xsd:documentation>Sequence to convert.</xsd:documentation>
	 </xsd:annotation>
	</xsd:element>
        <xsd:element name="tmp_infile" type="xsd:string" minOccurs="0">
	 <xsd:annotation>
	  <xsd:documentation>Name of the file with input sequence on the server. You need to supply either this parameter or the previous one (sequence).</xsd:documentation>
	 </xsd:annotation>
	</xsd:element>
	<xsd:element name="from" type="xsd:string" minOccurs="1">
	 <xsd:annotation>
	  <xsd:documentation>Format of input sequence (embl, fasta, filelist, gcg, genbank, ig, maf, multi, ncbi, raw, tab, wc, wconsensus).</xsd:documentation>
	 </xsd:annotation>
	</xsd:element>
	<xsd:element name="to" type="xsd:string" minOccurs="1">
	 <xsd:annotation>
	  <xsd:documentation>Format of output sequence (fasta, filelist, ft, ig, multi, raw, tab, wc, wconsensus).</xsd:documentation>
	 </xsd:annotation>
	</xsd:element>
       </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="CompareClassesRequest">
	<xsd:annotation>
	  <xsd:documentation>Parameters for the operation compare_classes.</xsd:documentation>
	</xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="ref_classes" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>A tab-delimited text file containing the description of reference classes</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="query_classes" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>A tab-delimited text file containing the description of query classes</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="return_fields" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>List of fields to return separated by a comma. Supported: dotprod, entropy, freq, jac_sim, members, occ, proba, rank</xsd:documentation>
            </xsd:annotation>
          </xsd:element> 
          <xsd:element name="score_column" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Specify a column of the input file containing a score associated to each member</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="input_classes" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>This file will be used as both reference and query.This is equivalent to -q input_file -r input_file.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="upper_threshold_field" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Supported fields: E(QR), E_val, F(!Q!R), F(Q!R), F(Q), F(QR), F(R!Q), F(R), H(Q), H(Q,R), H(Q|R), H(R), H(R|Q), 
I(Q,R), IC, P(QR), P(Q|R), P(R|Q), P_val, Q, QR, QvR, R, U(Q|R), U(R|Q), dH(Q,R), dotprod, jac_sim, rank, sigE(QR), 
E_val, F(!Q!R), F(Q!R), F(Q), F(QR), F(R!Q), F(R), H(Q), H(Q,R), H(Q|R), H(R), H(R|Q), I(Q,R), IC, P(QR), P(Q|R), 
P(R|Q), P_val, Q, QR, QvR, R, U(Q|R), U(R|Q), dH(Q,R), dotprod, dp_bits, jac_sim, log2_dp, names, prodrts, sig, sqrt_dp.
Separate with semicolumn (":") as there are fields containing commas.</xsd:documentation>
            </xsd:annotation>
          </xsd:element> 
          <xsd:element name="upper_threshold_value" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Upper threshold value for a supported field. There must be as many thresholds values as thresholds fields in the same order as the list of threshold fields were given. </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="lower_threshold_field" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Supported fields: same fields as upper_threshold_field.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="lower_threshold_value" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Lower threshold value for a given field.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="sort" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Sort on the basis of the specified key.</xsd:documentation>
            </xsd:annotation>
          </xsd:element> 
          <xsd:element name="distinct" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Prevent to compare each class with itself (when the reference and query files contain the same classes)</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="triangle" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>(only valid if query file and reference file are the same) Do not perform the reciprocal comparisons.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>  
	  <xsd:element name="matrix" type="xsd:string" minOccurs="0">
            <xsd:annotation>
            <xsd:documentation>Return a pairwise matrix, where each row corresponds to a reference class, each column to a query class, and each cell contains a comparison between the two classes. 
The next argument indicates which statistics has to be return in the matrix (default = sig) 
Supported: E(QR), E_val, F(!Q!R), F(Q!R), F(Q), F(QR), F(R!Q), F(R), H(Q), H(Q,R), H(Q|R), H(R), H(R|Q), I(Q,R), IC, P(QR), P(Q|R), P(R|Q),
P_val, Q, QR, QvR, R, U(Q|R), U(R|Q), dH(Q,R), dotprod, jac_sim, rank, sig</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ConvertClassesRequest">
	<xsd:annotation>
	  <xsd:documentation>Parameters for the operation convert-classes.</xsd:documentation>
	</xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="informat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Input format : supported tab, profiles, mcl</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outformat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Output format : supported tab, profiles, mcl</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="member_col" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Member column. Column containing the member names in the tab format (default 1).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	  <xsd:element name="class_col" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Class column. Column containing the class names in the tab format  (default 2).</xsd:documentation>
            </xsd:annotation>
          </xsd:element> 
          <xsd:element name="score_col" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Score column. Column containing the score in the tab format : if not specified, scores are not defined..</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="min_score" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Minimal score value for member to class assignation.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="inputclasses" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Input classes in the format defined by the input_format tag</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="names" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Two tab-delimited columns specifying the labels of the members of the classification given in the classification file.
First column contains the identifier and second column the corresponding label.</xsd:documentation>
            </xsd:annotation>
          </xsd:element> 
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ContingencyTableRequest">
	<xsd:annotation>
	  <xsd:documentation>Parameters for the operation contingency_table.</xsd:documentation>
	</xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputfile" type="xsd:string" minOccurs="1">
            <xsd:annotation>
              <xsd:documentation>A tab delimited file</xsd:documentation>
            </xsd:annotation>
	  </xsd:element> 
	  <xsd:element name="col1" type="xsd:int" minOccurs="1">
            <xsd:annotation>
              <xsd:documentation>First column to use for the contingency table</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="col2" type="xsd:int" minOccurs="1">
            <xsd:annotation>
              <xsd:documentation>Second column to use for the contingency table</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="margin" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Calculate the marginal sums</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="null" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Value for the null character (default: 0).</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ContingencyStatsRequest">
	<xsd:annotation>
	  <xsd:documentation>Parameters for the operation contingency-stats.</xsd:documentation>
	</xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="inputfile" type="xsd:string" minOccurs="1">
            <xsd:annotation>
              <xsd:documentation>A contingency table : a N*M table used to compare the contents of two classifications. 
Rows represent the clusters of the first classification (considered as reference), and columns the clusters of the second classification (query).</xsd:documentation>
            </xsd:annotation>
          </xsd:element> 
          <xsd:element name="decimals" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Number of decimals to display for the computed statistics.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="return" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>List of fields to return.
    stats : table-wise statistics
    rowstats : row-wise statistics (one line per row of the contingency table)
    colstats : column-wise statistics (one line per column of the contingency table)
    tables : full tables for each statistics (counts, Sn, PPV, separation).
    margins : marginal statistics besides the tables (requires to return tables).</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="rsizes" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Specify row group sizes in a separate file.
This option can be used in particular cases where the marginal sum of the contingency table does not correspond to the group sizes 
(for example if a classification supports the same elements assigned to multiple groups, or on the contrary if some elements can be unassigned).
The row size file must contain one row per row of the contingency table, and two columns. The first column indicated the name of the row 
(the same name as in the contingency table), and the second the size of the corresponding group.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="csizes" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Specify column group sizes in a separate file. Same description as for -rsizes tag.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="MatrixDistribRequest">
	<xsd:annotation>
	  <xsd:documentation>Parameters for the operation matrix_distrib</xsd:documentation>
	</xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="matrix_file" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>The matrix file content. Matrix format is specified with the option "matrix_format" (see below) Default format: tab.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_matrix_file" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>Name of the file containing matrix on the server. You need to supply either this parameter or the previous one (matrix_file).</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="matrix_format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Supported fields: tab, cb, consensus, gibbs, meme, assembly.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element> 
	  <xsd:element name="matrix_pseudo" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Pseudo counts to apply on the matrix. Default: 1.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Background model file is a tab-delimited file containing the specification of oligonucleotide frequencies.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background_pseudo" type="xsd:float" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Pseudo frequency for the background models. Value must be a real between 0 and 1. Default: 0.01.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="decimals" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Number of decimals for the matrix frequencies.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background_format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Background format.upported formats: all the input formats supported by convert-background-model.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="MatrixScanRequest">
	<xsd:annotation>
	  <xsd:documentation>Parameters for the operation matrix_scan</xsd:documentation>
	</xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sequence" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Sequence(s) to scan - all the formats supported in RSAT can be used as input (default: fasta)</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	<xsd:element name="tmp_sequence_infile" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Name of the file with input sequence(s) on the server. You need to supply either this parameter or the previous one (sequence).</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	  <xsd:element name="matrix" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Matrix/ces to scan with. The matrix format is specified with the option "matrix_format" (see below) Default format: tab.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	<xsd:element name="tmp_matrix_infile" type="xsd:string" minOccurs="0">
	  <xsd:annotation>
	    <xsd:documentation>Name of the file with input matrix/ces on the server. You need to supply either this parameter or the previous one (matrix).</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	  <xsd:element name="sequence_format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Supported fields: fasta (default), IG (Intelligenetics), WC (wconsensus), raw.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="matrix_format" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Supported fields: tab, cb, consensus, gibbs, meme, assembly.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="n_treatment" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Treatment of N characters. These characters are often used in DNA sequences to represent undefined or masked nucleotides.
        skip
            N-containing regions are skipped.
        score
            N-containing regions are scored. The probability of an N is 1 for both the background model and the matrix. The N residues
            will thus contribute neither positively nor negatively to the weight score of the N-containing fragment. This option can be
            useful to detect sites which are at the border of N-containing regions, or in cases there are isolated N in the sequences.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="consensus_name" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Use the motif (degenerate) consensus as matrix name.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="pseudo" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Pseudo-count for the matrix (default: 1).
The pseudo-count reflects the possibility that residues that were not (yet) observed in the model might however be valid for future observations.
The pseudo-count is used to compute the corrected residue frequencies..</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="equi_pseudo" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>If this option is called, the pseudo-weight is distributed in an equiprobable way between residues.
By default, the pseudo-weight is distributed proportionally to residue priors, except for the -window option where equipseudo is default.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="top_matrices" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Only scan with the top # matrices per matrix file.
This option is valid for some file formats containing multiple matrices where top matrices are generally more informative.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background_model" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Background model is a tab-delimited specification of oligonucleotide frequencies.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tmp_background_infile" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Background model file (tab-delimited specification of oligonucleotide frequencies) on the server.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="organism" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>To use a precalculated background model from RSAT, choose the organism corresponding to the background model.
Works with background and markov options.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>To use a precalculated background model from RSAT. Works with organism and markov options.
Type of sequences used as background model for estimating expected oligonucleotide frequencies. 
Supported: upstream, upstream-noorf, upstream-noorf-rm, intergenic</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background_input" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Calculate background model from the input sequence set.
This option requires to specify the order of the background model with the option markov.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background_window" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Size of the sliding window for the background model calculation.
This option requires to specify the order of the background model with the option markov (suitable for short order model only markov 0 or 1)</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="markov" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Order of the markov chain for the background model. This option is incompatible with the option background.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background_pseudo" type="xsd:float" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Pseudo frequency for the background models. Value must be a real between 0 and 1.
If this option is not specified, the pseudo-frequency value depends on the background calculation.
For -bginput and -window, the pseudo frequency is automatically calculated with the length (L) of the sequence following this formula:
    square-root of L divided by L+squareroot of L
For -bgfile, default value is 0.01.
If the training sequence length (L) is known, the value can be set by -bg_pseudo option to square-root of L divided by L+squareroot of L.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return_fields" type="xsd:string" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>List of fields to return. Supported fields: sites, rank, limits, normw, bg_model, matrix, freq_matrix, weight_matrix, distrib .</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sort_distrib" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
              <xsd:documentation>Sort score distribution by decreasing value of significance, if value = 1.
By default, the score distributions are sorted by score (weight).</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	<xsd:element name="lth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	  <xsd:annotation>
	    <xsd:documentation>Lower threshold on some parameter. Format=list of 'parameter value'.
Supported fields: score, pval, eval, sig, normw, proba_M, proba_B, rank, crer_sites, crer_size, occ, occ_sum, inv_cum, 
exp_occ, occ_pval, occ_eval, occ_sig, occ_sig_rank</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	<xsd:element name="uth" type="xsd:string" minOccurs="0" maxOccurs="unbounded">
	  <xsd:annotation>
	    <xsd:documentation>Upper threshold on some parameter. Format=list of 'param value'.
Supported parameters: same as lth.</xsd:documentation>
	  </xsd:annotation>
	</xsd:element>
	  <xsd:element name="str" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Scan 1 or 2 strands for DNA sequences.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="verbosity" type="xsd:int" minOccurs="0">
            <xsd:annotation>
              <xsd:documentation>Level of verbosity (detail in the warning messages during execution)</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="origin" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
              <xsd:documentation>Define the origin for the calculation of positions.
-origin -0 defines the end of each sequence as the origin.
The matching positions are then negative values, providing the distance between the match and the end of the sequence.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="decimals" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
              <xsd:documentation>Number of decimals displayed for the weight score.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="crer_ids" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
              <xsd:documentation>Assign one separate feature ID per CRER. This option is convenient to distinguish separate CRERs.</xsd:documentation>
            </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ConvertMatrixRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation convert_matrix.</xsd:documentation>
        </xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="matrix" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Matrix (or assembly or features) you want to convert.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background_format" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Format for the background model (prior) files. Supported: oligo-analysis, MotifSampler, meme, dyads.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="background_pseudo" type="xsd:float" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Pseudo frequency for the background models. Value must be a real between 0 and 1 (default: 0.01).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="from" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input matrix format. Supported: alignace, assembly, cb, clustal, consensus, feature, gibbs, infogibbs, meme, motifsampler, tab, transfac.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="to" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Output matrix format. Supported: consensus, patser, tab, transfac.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Result type (matrix content). Supported: consensus, counts, frequencies, info, information, logo, margins, parameters, profile, sites, wdistrib, weights.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sort" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>desc | asc | alpha sort_key.
Sort matrices according to the specified attribute (sort_key). The sorting can be done on numerical values, either in descending (desc) or ascending (asc) order.
It can also be done in alphabetical order (alpha).
The key must be one of the numeric parameters of the matrices (e.g. information.content, E-value, ...).
This option is convenient, for example, to sort matrices from MotifSampler according to their information content:
        -sort desc MS.ic.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="top" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximal number of matrices to return. 
Some of the input formats can contain several matrices in a single file (e.g. consensus, meme, MotifSampler).
By default, all the matrices are parsed and exported. The option -top allows to restrict the number of matrices to be exported.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="pseudo" type="xsd:float" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>pseudo-weight used for the calculation of the weight matrix (default: 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="equi_pseudo" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>If value is 1, the pseudo-weight is distributed in an equiprobable way between residues.
By default, the pseudo-weight is distributed proportionally to residue priors.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="base" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Base for the logarithms used in the scores involving a log-likelihood (weight and information content). Default: exp(1) (natural logarithms).
A common alternative to natural logarithms is to use logarithms in base 2, in which case the information content is computed in bits..</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="decimals" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of decimals to print for real matrices (frequencies, weights, information) or to compute score distributions.
Warning: for the computation of score distributions, the computing time increases exponentially with the number of decimals.
We recommend to restrict the precision to 2 decimals for the weight, this is generally more than sufficient.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="perm" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of permuted matrices to return.
Matrix columns are permuted so that the total information content remains identical to the original matrix.
Note that the output format for permuted matrix is tab.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="max_profile" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximal width of the profile histogram (units = number of characters).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="rc" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Convert the matrix to its reverse complement if value = 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RandomSequenceRequest">
        <xsd:annotation>
	  <xsd:documentation>Parameters for the operation random_seq.</xsd:documentation>
        </xsd:annotation>
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
          <xsd:element name="sequence_length" type="xsd:int" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Length of sequence to generate.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="repetition" type="xsd:int" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Number of sequences to generate.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="format" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Format of sequence(s) to generate.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="line_width" type="xsd:int" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>A newline character will be inserted in the sequence every # bases, where # is the number provided. 
Default is 70. A value of 0 will prevent newline insertion.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="type" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Type of sequence(s) to generate (protein | DNA | other).</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="seed" type="xsd:int" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Seed for the random generator.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="alphabet" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Alphabet. Must be followed by residue frequencies expressed precisely this way:    a:t # c:g #</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="expfreq" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Expected frequencies of oligomers in sequence(s) to generate. Indicate the file that contains expected oligomer frequencies. 
When this option is used, the sequences are generated according to a Markov chain.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="tmp_expfreq_file" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Name of the file with expected frequencies on the server.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="bg_model" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Background model. Automatically load a pre-calibrated exected frequency file from the RSAT genome distribution. 
When this option is used, the options organism and oligo_length are also required, to indicate the organism and the oligonucleotide length, respectively.
This option is incompatible with the option expfreq.                 
Type of sequences used as background model for estimating expected oligonucleotide frequencies (supported models):
  - equi (equiprobable residue frequencies [default]), 
  - upstream (all upstream sequences, allowing overlap with upstream ORFs. Requires to speciy a model organism), 
  - upstream-noorf (all upstream sequences, preventing overlap with upstream ORFs. Requires to specify a model organism), and 
  - intergenic (intergenic frequencies. Whole set of intergenic regions, including upstream and downstream sequences. Requires to specify a model organism).</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="organism" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Name of the organism when using a background model.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
         <xsd:element name="oligo_length" type="xsd:int" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Length of oligomer when using a background model.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
	 <xsd:element name="length_file" type="xsd:string" minOccurs="0">
	   <xsd:annotation>
	     <xsd:documentation>Length file. Allows to generate random sequences with the same lengths as a set of reference sequences.
The length file contains two columns : sequence ID (ignored) and sequence length.</xsd:documentation>
	   </xsd:annotation>
	 </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <!-- NeA TOOLS REQUESTS -->
      <xsd:complexType name="ConvertGraphRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="informat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml, adj_matrix.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="ecolors" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Compute an edge color for the GML output. The color intensity is proportional to the weight of the edge.
All weights in the column indicated by the -wcol argument must thus be real values.
Supported: green, blue, red, fire, grey.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outformat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: tab, gml, dot, adj_matrix.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label for the tab-delimited format (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="eccol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that containsthe color of the edge (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sccol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the color of the source node (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tccol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the color of the target node (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="pathcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify the column containing the paths</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="undirected" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>The graph is considered as being undirected (useful for the adjacency matrix input and output).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="distinct_path" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>The nodes belonging to different paths are duplicated with this option</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="layout" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify whether the disposition of each node has to be calculated using the $RSAT/bin/fr_layout program.
This option is only useful for GML output.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="ewidth" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Calculate the edge width for the GML output. The width is proportional to the weight of the edge.
This value can only be computed for the GML output. All weights in the column indicated by the -wcol argument must thus be real values.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="target_xpos_col" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Column containing the X position of the target node</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="target_ypos_col" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Column containing the Y position of the target node</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="source_xpos_col" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Column containing the X position of the source node</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="source_ypos_col" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Column containing the Y position of the source node</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="AlterGraphRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="informat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml, adj_matrix.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outformat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: tab, gml, dot, adj_matrix.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label for the tab-delimited format (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="directed" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specifies whether the edges must be considered as directed, i.e., an     edge from node A to node B is different from an edge from B to A (by default, edges are not directed).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="duplicate" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specifies whether more than one edge may link two nodes. (by default, duplicated edges are not allowed).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="self" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Allows self loops (by default, self loops are not allowed)</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="target" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Nodes that have to be removed in the graph (if existing). The node names must be separated by comas.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="add_nodes" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of edges to add. This value can either be a percentage value or a discrete number.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="rm_nodes" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of edges to remove. This value can either be a percentage value or a discrete number.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="add_edges" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of edges to add. This value can either be a percentage value or a discrete number.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="rm_edges" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of edges to remove. This value can either be a percentage value or a discrete number.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphCliquesRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="informat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml, adj_matrix.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="min_size" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Minimum size of the clique to return.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>      

      <xsd:complexType name="DisplayGraphRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="informat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml, adj_matrix.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outformat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: ps, png, jpeg.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="ewidth" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Calculate the edge width for the GML output. The width is proportional to the weight of the edge. This value can only be
computed for the GML output. All weights in the column indicated by the -wcol argument must thus be real values.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label for the tab-delimited format (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="eccol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that containsthe color of the edge (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sccol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the color of the source node (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tccol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the color of the target node (no default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="layout" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Calculates the layout according to the Fruchterman and Reingold algorithm.
This option must be provided if the input graph is not GML.
	      </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="DrawHeatmapRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outformat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: png, jpeg.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="html" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Returns an HTML file that load the heatmap. The name of this file is the name of the output file on the server with the html extension </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputfile" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="row_names" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Use this option if the first column contain the row names.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="no_text" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Using this option, the values are not written in the cells of the heatmap</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="col_width" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Width of the columns (in pixel). If the row height is to small, the label of the heatmap will not be indicated. (Default : 50 px)</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="row_height" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Height of the rows (in pixel). If the row height is to small, the label of the heatmap will not be indicated. (Default : 30 px)</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="min" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Minimal value of the heatmap. By default, this value is the minimal value of the input file.
If the specified value is larger than the minimal value of the heatmap, then the minimal value of the heatmap will be used as minimal value.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="max" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximal value of the heatmap. By default, this value is the maximal value of the input file.
If the specified value is smaller than the maximal value of the heatmap, then the maximal value of the heatmap will be used as maximal value.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="gradient" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Color of the intensity gradient of the heatmap. Default is grey.
Supported : green, blue, red, fire, grey.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="CompareGraphsRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Qinformat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input format of query graph. Supported: tab, gml.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Rinformat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input format of reference graph. Supported: tab, gml.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outformat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: tab, gml, dot.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outweight" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Q (weights of the query graph), R (weights of the reference graph), sum (sum of the weights of the two graphs), 
mean (mean of the weights of the two graphs), mean.g (geometrical mean of the weights of the two graphs),
min (minimum weight), max (maximum weight), Q::R (weight of the two graphs) (default).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Rinputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>The reference graph in the format specified by the informat tag.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Qinputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>The query graph in the format specified by the informat tag</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Qwcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the query input graph that contains an edge weight or an edge label (default none) for the tab-delimited format.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Qscol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the query input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Qtcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the query input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Rwcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the reference input graph that contains an edge weight or an edge label (default none) for the tab-delimited format.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Rscol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the reference input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="Rtcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the reference input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>intersection, union, difference, R.and.Q, Q.and.R, Q.or.R, Q.not.R, R.not.Q, Q.and.R+Q, 
Q.and.R+R, R.and.Q+Q, R.and.Q+R, intersection+Q, intersection+R.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="directed" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Indicates whether the graphs must be considered as directed, i.e., an arc from node A to node B is different from an arc from B to A.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="self" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Indicates whether the graphs can admit self-loops, i.e., an arc from a node to itself. 
Note that the graphs do not specially need to contain actual self-loops, the question is whether 
it would or not be acceptable for the considered input graphs to contain self-loops.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphNodeDegreeRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="informat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="all" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>The degree of all nodes will be computed.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="nodefile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A file containing the nodes for which you want to know the degree.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label (default none) for the tab-delimited format.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>
      
      <xsd:complexType name="GraphTopologyRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="informat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="all" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>The statistics will be computed for all nodes.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>return type : degree, closeness, betweenness. More than one statistics can be returned by separating the fields with ','.
To return all implemented statistics, you can use all.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="nodefile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A file containing the nodes for which you want to know the degree and other statistics.</xsd:documentation>
	    </xsd:annotation>
          </xsd:element>
	  <xsd:element name="directed" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specifies whether the graph is directed or not (i.e. edge A-B corresponds to edge B-A).
In this case, the betweenness and the closeness calculation will be rather different.
By default the graph is not directed.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label (default none) for the tab-delimited format.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphClusterMembershipRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="informat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="clusters" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>clustering as a tab-delimited file.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="stat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Determines how the node membership will be calculated (edge, weight, relw).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="decimals" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of decimals to print for the membership. Note that by selecting this option, the entries of the membership-vectors (rows) won't sum up to 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label (default none) for the tab-delimited format.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RandomGraphRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="informat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outformat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: tab, gml, dot.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="random_type" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Randomization type:
- scratch (de novo graph) : don't forget to specify the number of nodes and of edges,
- ER (Erdos-Renyii randomization) : corresponds to the randomization of a input graph, keeping the nodes and the number of edges but changing its characteristics,
- node_degree : each node will keep the same degree that in the input graph (edge randomization),
- node_degree_distrib : the global distribution of node degree will remain the same as in the input graph.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label (default none) for the tab-delimited format.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="edges" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of requested edges (for scratch randomization type).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="degree" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximal degree of the nodes in the ER random graph.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="nodes" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Number of requested nodes (for scratch randomization type).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="self" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Allows self loops (by default, self loops are not allowed)</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="mean" type="xsd:float" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Mean value on the weight of the arcs.
This argument can only be used with the scratch and ER randomization type and must be combined with the -sd option.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="sd" type="xsd:float" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Standard deviation value of the weight of the arcs.
This argument can only be used with the scratch and ER randomization type and must be combined with the -mean option.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="directed" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Indicates whether the graphs must be considered as directed, i.e., an arc from node A to node B is different from an arc from B to A.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="no_single" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Prevent the ER / scratch graph from containing nodes with no neighbour.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="duplicate" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specifies whether more than one edge may link two nodes (by default, duplicated edges are not allowed).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="col_conservation" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Only compatible with ER randomization of a graph. Source and target nodes stay source and target nodes in the randomized graph.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="normal" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>This option can only be used with ER randomization type and if the input graph is weighted. 
Using this option will generate randomly the weight of the output random graph according to a normal distribution of weights. 
The mean and standard deviation can then be chosen (-mean and -sd option) or will be calculated according to the weights the input graph.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="MCLRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the tab delimited format first column : source node, second column : target node, third column : edge weight</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inflation" type="xsd:float" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Sets the main inflation value. This value is the main handle for affecting cluster granularity. It is usually chosen somewhere in the range [1.2-5.0].
-I 5.0 will tend to result in fine-grained clusterings, and -I 1.2 will tend to result in very coarse grained clusterings.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>      

      <xsd:complexType name="RNSCRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format required by RNSC : an adjacency list in which each edge appears only once.
The vertices are labelled with the integers 0, 1, ..., n-1. The list of neighbours for vertex v appears as v n_1 n_2 ... n_x -1.
The input network in the correct format can be produced by the convert-graph program.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="max_clust" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Allow no more than "num" clusters.  "num" must be between 2 and n, where n is the number of vertices in the graph.
If this option is not specified or an invalid value is given, n clusters are used.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tabulength" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Set the tabu length to "num". Default value is 1. Note that when the tabulist option is used, vertices can appear 
on the tabu list more than once and moving them is only forbidden when they are on the tabu list more than TabuTol times, where TabuTol is the tabu list tolerance.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tabulist" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Set the tabu list tolerance to "num". Default value is 1.
The tabu list tolerance is the number of times a vertex must appear on the tabu list before moving it is forbidden.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="naive_stop" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Set the naive stopping tolerance to "num". Default value is 5. This is the number of steps that the naive scheme will continue without improving the best cost.
If you run the scaled scheme, using a higher naive stopping tolerance isn't likely to improve your results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scale_stop" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Set the scaled stopping tolerance to "num". Default value is 5. This is the number of steps that the scaled scheme will continue without improving the best cost.
Setting the tolerance to 0 will cause the algorithm to skip the scaled scheme.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="exp_nb" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Run "num" experiments. The best final clustering over all experiments will be written to file. Default is 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="div_freq" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Set the diversification frequency to "num". Without this option, no diversification will be performed.
If the shf_div_len flag is also used, then "num" is the shuffling diversification frequency.
If the -d flag is not used, then "num" is the destructive diversification frequency.
It is recommended that the shf_div_len flag is used, because destructive diversification isn't much help.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="shf_div_len" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Set the shuffling diversification length to "num". That means that the last "num" moves in the diversification period will be diversification moves.
Don't set this to be higher than the diversification frequency.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphNeighboursRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="informat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Input graph. Supported: tab, gml.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="direction" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Direction of the neighbours (default all). Supported: in, out, all. This option cannot be used with the stat output and when specifying the number of steps</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="all" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>The neighbours of all nodes will be searched.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="stats" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Only valid when the number of step is equal to 1. The output file is presented differently, with one line for each seed node.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="self" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Include each node in its neighborhood, with a distance of 0, even if there is no self-loop at this node. 
This allows to extract the node together with its neighborhood, rather than the neighborhood only (default). This option cannot be used with the stats option.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="seedfile" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>A list of nodes for which you want to know the neighbours.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label (default none) for the tab-delimited format.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="steps" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Maximal number of steps between a seed node and its neighbours. Default: 1.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphGetClustersRequest">
	<xsd:sequence>
	  <xsd:element name="output" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Return type.
Accepted values: 'server' (result is stored on a file on the server), 'client' (result is directly transferred to the client),
'both' (result is stored on the server and transferred to the client), and ticket (an identifier, allowing to monitor the job status and retrieve the result when it is done, is returned to the client).
Default is 'both'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="informat" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Input format. Supported: tab, gml.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="return" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Return format. Supported: table, cluster, graph.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="outformat" type="xsd:string" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Output format. Supported: tab, gml, dot.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="inputgraph" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>A graph in the format specified by the informat tag.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="clusters" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Specification of the clusters to which belong the nodes.</xsd:documentation>	
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="wcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains an edge weight or an edge label (default none) for the tab-delimited format.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="scol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the source nodes for the tab-delimited format (default = 1).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="tcol" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Specify a column of the input graph that contains the target nodes for the tab-delimited format (default = 2).</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="distinct" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>As some nodes may belong to more than one group, using this option will duplicate the nodes belonging to more than one group.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="induced" type="xsd:int" minOccurs="0">
	    <xsd:annotation>
	      <xsd:documentation>Using this option, only the first column of the cluster file will be taken into account. 
The output graph will thus consist in the graph induced by all nodes of the first column.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <!-- GENERAL UTILITY TOOLS REQUESTS -->
      <xsd:complexType name="MonitorRequest">
	<xsd:sequence>
	  <xsd:element name="ticket" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Ticket of a job submitted with its output_choice set to 'ticket'.                                                                                                                                                                                                          </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GetResultRequest">
	<xsd:sequence>
	  <xsd:element name="ticket" type="xsd:string" minOccurs="1">
	    <xsd:annotation>
	      <xsd:documentation>Ticket of a job submitted with its output_choice set to 'ticket'.                                                                                                                                                                                                           </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <!-- RSA TOOLS RESPONSES -->
      <xsd:complexType name="RetrieveSequenceResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RetrieveSequenceMultigenomeResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RetrieveEnsemblSequenceResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="PurgeSequenceResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="OligoAnalysisResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="DyadAnalysisResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="PatternAssemblyResponse">
        <xsd:sequence>
          <xsd:element name="server" type="xsd:string">
            <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="command" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="client" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The results.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="DnaPatternResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ConvertFeaturesResponse">
	<xsd:sequence>
          <xsd:element name="server" type="xsd:string">
            <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="command" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="client" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The results.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="FeatureMapResponse">
        <xsd:sequence>
          <xsd:element name="server" type="xsd:string">
            <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="command" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="client" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The results.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="FootprintDiscoveryResponse">
        <xsd:sequence>
          <xsd:element name="server" type="xsd:string">
            <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="command" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element name="client" type="xsd:string">
            <xsd:annotation>
              <xsd:documentation>The results.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GetOrthologsResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="InferOperonResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GeneInfoResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="SupportedOrganismsResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="TextToHtmlResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="parsepsixmlResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RocStatsResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="XYGraphResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ClassFreqResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ConvertSeqResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="CompareClassesResponse">
   	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ConvertClassesResponse">
   	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ContingencyStatsResponse">
   	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ContingencyTableResponse">
   	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="MatrixScanResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="ConvertMatrixResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>
      
       <xsd:complexType name="MatrixDistribResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RandomSequenceResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <!-- NeA TOOLS RESPONSES -->
      <xsd:complexType name="ConvertGraphResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>
      <xsd:complexType name="AlterGraphResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphCliquesResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="DisplayGraphResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="DrawHeatmapResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphNodeDegreeResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphTopologyResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphClusterMembershipResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="CompareGraphsResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphNeighboursResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="MCLResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RNSCResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="RandomGraphResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                    </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GraphGetClustersResponse">
	<xsd:sequence>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                             </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="command" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The stand-alone command executed on the server.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>The results.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <!-- GENERAL UTILITY TOOLS RESPONSES -->
      <xsd:complexType name="MonitorResponse">
	<xsd:sequence>
	  <xsd:element name="status" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Return status ('Running' or 'Done') of a job submitted with its output_choice set to 'ticket'.                                                                                                                                                                                             </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <xsd:complexType name="GetResultResponse">
	<xsd:sequence>
	  <xsd:element name="client" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Return result of job submitted with its output_choice set to 'ticket'.</xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	  <xsd:element name="server" type="xsd:string">
	    <xsd:annotation>
	      <xsd:documentation>Location of the result file on the server. This can be used as input for a further request.                                                                                                                                                                                             </xsd:documentation>
	    </xsd:annotation>
	  </xsd:element>
	</xsd:sequence>
      </xsd:complexType>

      <!-- RSA TOOLS MAIN ELEMENTS -->
      <xsd:element name="retrieve_seq">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:RetrieveSequenceRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="retrieve_seqResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:RetrieveSequenceResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="retrieve_seq_multigenome">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:RetrieveSequenceMultigenomeRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="retrieve_seq_multigenomeResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:RetrieveSequenceMultigenomeResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="retrieve_ensembl_seq">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:RetrieveEnsemblSequenceRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="retrieve_ensembl_seqResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:RetrieveEnsemblSequenceResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="purge_seq">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:PurgeSequenceRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="purge_seqResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:PurgeSequenceResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="oligo_analysis">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:OligoAnalysisRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="oligo_analysisResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:OligoAnalysisResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="dyad_analysis">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:DyadAnalysisRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="dyad_analysisResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:DyadAnalysisResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="pattern_assembly">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="request" type="tns:PatternAssemblyRequest" />
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>

      <xsd:element name="pattern_assemblyResponse">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="response" type="tns:PatternAssemblyResponse" />
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>

      <xsd:element name="dna_pattern">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:DnaPatternRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="dna_patternResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:DnaPatternResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_features">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="request" type="tns:ConvertFeaturesRequest" />
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_featuresResponse">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="response" type="tns:ConvertFeaturesResponse" />
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>

      <xsd:element name="feature_map">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="request" type="tns:FeatureMapRequest" />
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>

      <xsd:element name="feature_mapResponse">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="response" type="tns:FeatureMapResponse" />
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>

      <xsd:element name="footprint_discovery">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="request" type="tns:FootprintDiscoveryRequest" />
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>

      <xsd:element name="footprint_discoveryResponse">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="response" type="tns:FootprintDiscoveryResponse" />
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>

      <xsd:element name="get_orthologs">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:GetOrthologsRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="get_orthologsResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:GetOrthologsResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="infer_operon">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:InferOperonRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="infer_operonResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:InferOperonResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="gene_info">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:GeneInfoRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="gene_infoResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:GeneInfoResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="supported_organisms">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:SupportedOrganismsRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="supported_organismsResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:SupportedOrganismsResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="text_to_html">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:TextToHtmlRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="text_to_htmlResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:TextToHtmlResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="parse_psi_xml">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:parsepsixmlRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="parse_psi_xmlResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:parsepsixmlResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="roc_stats">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:RocStatsRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="roc_statsResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:RocStatsResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="classfreq">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:ClassFreqRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="classfreqResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:ClassFreqResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="xygraph">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:XYGraphRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="xygraphResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:XYGraphResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_seq">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:ConvertSeqRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_seqResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:ConvertSeqResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="compare_classes">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:CompareClassesRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="compare_classesResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:CompareClassesResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_classes">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:ConvertClassesRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_classesResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:ConvertClassesResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="contingency_stats">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:ContingencyStatsRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="contingency_statsResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:ContingencyStatsResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="contingency_table">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:ContingencyTableRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="contingency_tableResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:ContingencyTableResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="matrix_scan">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:MatrixScanRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="matrix_scanResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:MatrixScanResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_matrix">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:ConvertMatrixRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_matrixResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:ConvertMatrixResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="matrix_distrib">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:MatrixDistribRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="matrix_distribResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:MatrixDistribResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="random_seq">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:RandomSequenceRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="random_seqResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:RandomSequenceResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <!-- NeA TOOLS MAIN ELEMENTS -->
      <xsd:element name="convert_graph">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:ConvertGraphRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="convert_graphResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:ConvertGraphResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="alter_graph">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:AlterGraphRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="alter_graphResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:AlterGraphResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_cliques">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:GraphCliquesRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_cliquesResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:GraphCliquesResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="display_graph">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:DisplayGraphRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="display_graphResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:DisplayGraphResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="draw_heatmap">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:DrawHeatmapRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="draw_heatmapResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:DrawHeatmapResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="compare_graphs">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:CompareGraphsRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="compare_graphsResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:CompareGraphsResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_node_degree">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:GraphNodeDegreeRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_node_degreeResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:GraphNodeDegreeResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_topology">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:GraphTopologyRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_topologyResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:GraphTopologyResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_cluster_membership">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:GraphClusterMembershipRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_cluster_membershipResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:GraphClusterMembershipResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_neighbours">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:GraphNeighboursRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_neighboursResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:GraphNeighboursResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="mcl">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:MCLRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="mclResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:MCLResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="rnsc">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:RNSCRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="rnscResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:RNSCResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="random_graph">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:RandomGraphRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="random_graphResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:RandomGraphResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_get_clusters">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:GraphGetClustersRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="graph_get_clustersResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:GraphGetClustersResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <!-- GENERAL UTILITY TOOLS MAIN ELEMENTS -->
      <xsd:element name="monitor">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:MonitorRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="monitorResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:MonitorResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="get_result">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="request" type="tns:GetResultRequest" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

      <xsd:element name="get_resultResponse">
	<xsd:complexType>
	  <xsd:sequence>
	    <xsd:element name="response" type="tns:GetResultResponse" />
	  </xsd:sequence>
	</xsd:complexType>
      </xsd:element>

    </xsd:schema>
  </types>

  <!-- RSA TOOLS MESSAGES -->
  <message name="retrieve_seqRequest">
    <part name="parameters" element="tns:retrieve_seq"/>
  </message>

  <message name="retrieve_seqResponse">
    <part name="output" element="tns:retrieve_seqResponse"/>
  </message>

  <message name="retrieve_seq_multigenomeRequest">
    <part name="parameters" element="tns:retrieve_seq_multigenome"/>
  </message>

  <message name="retrieve_seq_multigenomeResponse">
    <part name="output" element="tns:retrieve_seq_multigenomeResponse"/>
  </message>

  <message name="retrieve_ensembl_seqRequest">
    <part name="parameters" element="tns:retrieve_ensembl_seq"/>
  </message>

  <message name="retrieve_ensembl_seqResponse">
    <part name="output" element="tns:retrieve_ensembl_seqResponse"/>
  </message>

  <message name="purge_seqRequest">
    <part name="parameters" element="tns:purge_seq"/>
  </message>

  <message name="purge_seqResponse">
    <part name="output" element="tns:purge_seqResponse"/>
  </message>

  <message name="oligo_analysisRequest">
    <part name="parameters" element="tns:oligo_analysis"/>
  </message>

  <message name="oligo_analysisResponse">
    <part name="output" element="tns:oligo_analysisResponse"/>
  </message>

  <message name="dyad_analysisRequest">
    <part name="parameters" element="tns:dyad_analysis"/>
  </message>

  <message name="dyad_analysisResponse">
    <part name="output" element="tns:dyad_analysisResponse"/>
  </message>

  <message name="pattern_assemblyRequest">
    <part name="parameters" element="tns:pattern_assembly"/>
  </message>

  <message name="pattern_assemblyResponse">
    <part name="output" element="tns:pattern_assemblyResponse"/>
  </message>

  <message name="dna_patternRequest">
    <part name="parameters" element="tns:dna_pattern"/>
  </message>

  <message name="dna_patternResponse">
    <part name="output" element="tns:dna_patternResponse"/>
  </message>

  <message name="convert_featuresRequest">
    <part name="parameters" element="tns:convert_features"/>
  </message>

  <message name="convert_featuresResponse">
    <part name="output" element="tns:convert_featuresResponse"/>
  </message>

  <message name="feature_mapRequest">
    <part name="parameters" element="tns:feature_map"/>
  </message>

  <message name="feature_mapResponse">
    <part name="output" element="tns:feature_mapResponse"/>
  </message>

  <message name="footprint_discoveryRequest">
    <part name="parameters" element="tns:footprint_discovery"/>
  </message>

  <message name="footprint_discoveryResponse">
    <part name="output" element="tns:footprint_discoveryResponse"/>
  </message>

  <message name="get_orthologsRequest">
    <part name="parameters" element="tns:get_orthologs"/>
  </message>

  <message name="get_orthologsResponse">
    <part name="output" element="tns:get_orthologsResponse"/>
  </message>

  <message name="infer_operonRequest">
    <part name="parameters" element="tns:infer_operon"/>
  </message>

  <message name="infer_operonResponse">
    <part name="output" element="tns:infer_operonResponse"/>
  </message>

  <message name="gene_infoRequest">
    <part name="parameters" element="tns:gene_info"/>
  </message>

  <message name="gene_infoResponse">
    <part name="output" element="tns:gene_infoResponse"/>
  </message>

  <message name="supported_organismsRequest">
    <part name="parameters" element="tns:supported_organisms"/>
  </message>

  <message name="supported_organismsResponse">
    <part name="output" element="tns:supported_organismsResponse"/>
  </message>
  
  <message name="text_to_htmlRequest">
    <part name="parameters" element="tns:text_to_html"/>
  </message>

  <message name="text_to_htmlResponse">
    <part name="output" element="tns:text_to_htmlResponse"/>
  </message>

  <message name="parse_psi_xmlRequest">
    <part name="parameters" element="tns:parse_psi_xml"/>
  </message>

  <message name="parse_psi_xmlResponse">
    <part name="output" element="tns:parse_psi_xmlResponse"/>
  </message>

  <message name="roc_statsRequest">
    <part name="parameters" element="tns:roc_stats"/>
  </message>

  <message name="roc_statsResponse">
    <part name="output" element="tns:roc_statsResponse"/>
  </message>
  
  <message name="classfreqRequest">
    <part name="parameters" element="tns:classfreq"/>
  </message>
  
  <message name="classfreqResponse">
    <part name="output" element="tns:classfreqResponse"/>
  </message>

  <message name="xygraphRequest">
    <part name="parameters" element="tns:xygraph"/>
  </message>

  <message name="xygraphResponse">
    <part name="output" element="tns:xygraphResponse"/>
  </message>

  <message name="convert_seqRequest">
    <part name="parameters" element="tns:convert_seq"/>
  </message>

  <message name="convert_seqResponse">
    <part name="output" element="tns:convert_seqResponse"/>
  </message>

  <message name="compare_classesRequest">
    <part name="parameters" element="tns:compare_classes"/>
  </message>

  <message name="compare_classesResponse">
    <part name="output" element="tns:compare_classesResponse"/>
  </message>

  <message name="convert_classesRequest">
    <part name="parameters" element="tns:convert_classes"/>
  </message>

  <message name="convert_classesResponse">
    <part name="output" element="tns:convert_classesResponse"/>
  </message>

  <message name="contingency_statsRequest">
    <part name="parameters" element="tns:contingency_stats"/>
  </message>

  <message name="contingency_statsResponse">
    <part name="output" element="tns:contingency_statsResponse"/>
  </message>

  <message name="contingency_tableRequest">
    <part name="parameters" element="tns:contingency_table"/>
  </message>

  <message name="contingency_tableResponse">
    <part name="output" element="tns:contingency_tableResponse"/>
  </message>

  <message name="matrix_scanRequest">
    <part name="parameters" element="tns:matrix_scan"></part>
  </message>

  <message name="matrix_scanResponse">
    <part name="output" element="tns:matrix_scanResponse"></part>
  </message>

  <message name="convert_matrixRequest">
    <part name="parameters" element="tns:convert_matrix"></part>
  </message>

  <message name="convert_matrixResponse">
    <part name="output" element="tns:convert_matrixResponse"></part>
  </message>

  <message name="matrix_distribRequest">
    <part name="parameters" element="tns:matrix_distrib"></part>
  </message>

  <message name="matrix_distribResponse">
    <part name="output" element="tns:matrix_distribResponse"></part>
  </message>

  <message name="random_seqRequest">
    <part name="parameters" element="tns:random_seq"/>
  </message>

  <message name="random_seqResponse">
    <part name="output" element="tns:random_seqResponse"/>
  </message>

  <!-- NeA TOOLS MESSAGES -->
  <message name="convert_graphRequest">
    <part name="parameters" element="tns:convert_graph"/>
  </message>

  <message name="convert_graphResponse">
    <part name="output" element="tns:convert_graphResponse"/>
  </message>

  <message name="alter_graphRequest">
    <part name="parameters" element="tns:alter_graph"/>
  </message>

  <message name="alter_graphResponse">
    <part name="output" element="tns:alter_graphResponse"/>
  </message>

  <message name="graph_cliquesRequest">
    <part name="parameters" element="tns:graph_cliques"/>
  </message>

  <message name="graph_cliquesResponse">
    <part name="output" element="tns:graph_cliquesResponse"/>
  </message>

  <message name="display_graphRequest">
	  <part name="parameters" element="tns:display_graph"/>
  </message>

  <message name="display_graphResponse">
	  <part name="output" element="tns:display_graphResponse"/>
  </message>

  <message name="draw_heatmapRequest">
	  <part name="parameters" element="tns:draw_heatmap"/>
  </message>

  <message name="draw_heatmapResponse">
	  <part name="output" element="tns:draw_heatmapResponse"/>
  </message>

  <message name="compare_graphsRequest">
    <part name="parameters" element="tns:compare_graphs"/>
  </message>

  <message name="compare_graphsResponse">
    <part name="output" element="tns:compare_graphsResponse"/>
  </message>

  <message name="graph_node_degreeRequest">
    <part name="parameters" element="tns:graph_node_degree"/>
  </message>

  <message name="graph_node_degreeResponse">
    <part name="output" element="tns:graph_node_degreeResponse"/>
  </message>

  <message name="graph_topologyRequest">
    <part name="parameters" element="tns:graph_topology"/>
  </message>

  <message name="graph_topologyResponse">
    <part name="output" element="tns:graph_topologyResponse"/>
  </message>

  <message name="graph_cluster_membershipRequest">
    <part name="parameters" element="tns:graph_cluster_membership"/>
  </message>

  <message name="graph_cluster_membershipResponse">
    <part name="output" element="tns:graph_cluster_membershipResponse"/>
  </message>

  <message name="random_graphRequest">
    <part name="parameters" element="tns:random_graph"/>
  </message>

  <message name="random_graphResponse">
    <part name="output" element="tns:random_graphResponse"/>
  </message>

  <message name="graph_get_clustersRequest">
    <part name="parameters" element="tns:graph_get_clusters"/>
  </message>

  <message name="graph_get_clustersResponse">
    <part name="output" element="tns:graph_get_clustersResponse"/>
  </message>

  <message name="graph_neighboursRequest">
    <part name="parameters" element="tns:graph_neighbours"/>
  </message>

  <message name="graph_neighboursResponse">
    <part name="output" element="tns:graph_neighboursResponse"/>
  </message>

  <message name="mclRequest">
    <part name="parameters" element="tns:mcl"/>
  </message>

  <message name="mclResponse">
    <part name="output" element="tns:mclResponse"/>
  </message>

  <message name="rnscRequest">
    <part name="parameters" element="tns:rnsc"/>
  </message>

  <message name="rnscResponse">
    <part name="output" element="tns:rnscResponse"/>
  </message>

  <!-- GENERAL UTILITY TOOLS MESSAGES -->
  <message name="monitorRequest">
    <part name="parameters" element="tns:monitor"/>
  </message>

  <message name="monitorResponse">
    <part name="output" element="tns:monitorResponse"/>
  </message>

  <message name="get_resultRequest">
    <part name="parameters" element="tns:get_result"/>
  </message>

  <message name="get_resultResponse">
    <part name="output" element="tns:get_resultResponse"/>
  </message>

  <portType name="RSATWSPortType">
    <!-- RSA TOOLS PORTTYPES -->
    <operation name="retrieve_seq">
      <documentation>Returns upstream, downstream or coding DNA sequences for list of query genes.</documentation>
      <input name="RetrieveSequenceRequest" message="tns:retrieve_seqRequest"/>
      <output name="RetrieveSequenceResponse" message="tns:retrieve_seqResponse"/>         
    </operation>
    <operation name="retrieve_seq_multigenome">
      <documentation>Returns upstream, downstream or coding DNA sequencesfor list of query genes and organisms.</documentation>
      <input name="RetrieveSequenceMultigenomeRequest" message="tns:retrieve_seq_multigenomeRequest"/>
      <output name="RetrieveSequenceMultigenomeResponse" message="tns:retrieve_seq_multigenomeResponse"/>         
    </operation>
    <operation name="retrieve_ensembl_seq">
      <documentation>Returns upstream, downstream or coding DNA sequences for list of query genes (in EnsEMBL database).</documentation>
      <input name="RetrieveEnsemblSequenceRequest" message="tns:retrieve_ensembl_seqRequest"/>
      <output name="RetrieveEnsemblSequenceResponse" message="tns:retrieve_ensembl_seqResponse"/>         
    </operation>
    <operation name="purge_seq">
      <documentation>Mask repeated fragments of an input sequence.</documentation>
      <input name="PurgeSequenceRequest" message="tns:purge_seqRequest"/>
      <output name="PurgeSequenceResponse" message="tns:purge_seqResponse"/>
    </operation>
    <operation name="oligo_analysis">
      <documentation>Analysis of the statistical significance of all the oligomers of a given size in a sequence. Commonly used to detect over-represented oligonucleotides in a set of promoter sequences.</documentation>
      <input name="OligoAnalysisRequest" message="tns:oligo_analysisRequest"/>
      <output name="OligoAnalysisResponse" message="tns:oligo_analysisResponse"/>
    </operation>
    <operation name="dyad_analysis">
      <documentation>Analysis of the statistical significance of all the spaced dyads of a given size in a sequence. Commonly used to detect over-represented spaced dyads in a set of promoter sequences.</documentation>
      <input name="DyadAnalysisRequest" message="tns:dyad_analysisRequest"/>
      <output name="DyadAnalysisResponse" message="tns:dyad_analysisResponse"/>
    </operation>
    <operation name="pattern_assembly">
      <documentation>Assemble a set of oligonucleotides or dyads into groups of overlapping patterns (assemblies).</documentation>
      <input name="PatternAssemblyRequest" message="tns:pattern_assemblyRequest"/>
      <output name="PatternAssemblyResponse" message="tns:pattern_assemblyResponse"/>
    </operation>
    <operation name="dna_pattern">
      <documentation>Searches all occurrences of a pattern within DNA sequences.</documentation>
      <input name="DnaPatternRequest" message="tns:dna_patternRequest"/>
      <output name="DnaPatternResponse" message="tns:dna_patternResponse"/>
    </operation>
    <operation name="convert_features">
      <documentation>Interconversions between various formats of feature description.</documentation>
      <input name="ConvertFeaturesRequest" message="tns:convert_featuresRequest"/>
      <output name="ConvertFeaturesResponse" message="tns:convert_featuresResponse"/>
    </operation>
    <operation name="feature_map">
      <documentation>Draws a graphical map of features (e.g. results of pattern matching) in a set of sequences.</documentation>
      <input name="FeatureMapRequest" message="tns:feature_mapRequest"/>
      <output name="FeatureMapResponse" message="tns:feature_mapResponse"/>
    </operation>
    <operation name="footprint_discovery">
      <documentation>Detect phylogenetic footprints by applying dyad-analysis in promoters of a set of orthologous genes.</documentation>
      <input name="FootprintDiscoveryRequest" message="tns:footprint_discoveryRequest"/>
      <output name="FootprintDiscoveryResponse" message="tns:footprint_discoveryResponse"/>
    </operation>
    <operation name="get_orthologs">
      <documentation>Get orthologuous genes.</documentation>
      <input name="GetOrthologsRequest" message="tns:get_orthologsRequest"/>
      <output name="GetOrthologsResponse" message="tns:get_orthologsResponse"/>
    </operation>
    <operation name="infer_operon">
      <documentation>Infer operon.</documentation>
      <input name="InferOperonRequest" message="tns:infer_operonRequest"/>
      <output name="InferOperonResponse" message="tns:infer_operonResponse"/>
    </operation>
    <operation name="gene_info">
      <documentation>Get information about genes.</documentation>
      <input name="GeneInfoRequest" message="tns:gene_infoRequest"/>
      <output name="GeneInfoResponse" message="tns:gene_infoResponse"/>
    </operation>
    <operation name="supported_organisms">
      <documentation>List RSAT suppported organisms.</documentation>
      <input name="SupportedOrganismsRequest" message="tns:supported_organismsRequest"/>
      <output name="SupportedOrganismsResponse" message="tns:supported_organismsResponse"/>
    </operation>
    <operation name="text_to_html">
      <documentation>Converts a tab-delimited file into a HTML table</documentation>
      <input name="TextToHtmlRequest" message="tns:text_to_htmlRequest"/>
      <output name="TextToHtmlResponse" message="tns:text_to_htmlResponse"/>
    </operation>
    <operation name="parse_psi_xml">
      <documentation>Converts a psi xml file in a tab delimited file</documentation>
      <input name="parsepsixmlRequest" message="tns:parse_psi_xmlRequest"/>
      <output name="parsepsixmlResponse" message="tns:parse_psi_xmlResponse"/>
    </operation>
    <operation name="roc_stats">
      <documentation>Computes, from a set of scored results associated with validation labels, the derived statistics (Sn, PPV, FPR), which can be further used to draw a ROC curve.</documentation>
      <input name="RocStatsRequest" message="tns:roc_statsRequest"/>
      <output name="RocStatsResponse" message="tns:roc_statsResponse"/>
    </operation>
    <operation name="xygraph">
      <documentation>Plot a graph and export it.</documentation>
      <input name="XYGraphRequest" message="tns:xygraphRequest"/>
      <output name="XYGraphResponse" message="tns:xygraphResponse"/>
    </operation>
    <operation name="classfreq">
      <documentation>This script takes a group of numbers (real or integers) and outputs their distribution among classes.</documentation>
      <input name="ClassFreqRequest" message="tns:classfreqRequest"/>
      <output name="ClassFreqResponse" message="tns:classfreqResponse"/>
    </operation>
    <operation name="convert_seq">
      <documentation>Converts a sequence between two formats (e.g. fasta -> raw).</documentation>
      <input name="ConvertSeqRequest" message="tns:convert_seqRequest"/>
      <output name="ConvertSeqResponse" message="tns:convert_seqResponse"/>
    </operation>
    <operation name="compare_classes">
      <documentation>Compare two class files(the query file and the reference file). Each class of the query file is compared to each class of the reference file. The number of common elements is reported, as well as the probability to observe at least this number of common elements by chance alone.</documentation>
      <input name="CompareClassesRequest" message="tns:compare_classesRequest"/>
      <output name="CompareClassesResponse" message="tns:compare_classesResponse"/>
    </operation>
    <operation name="convert_classes">
      <documentation>Interconversions between different formats of cluster files.</documentation>
      <input name="ConvertClassesRequest" message="tns:convert_classesRequest"/>
      <output name="ConvertClassesResponse" message="tns:convert_classesResponse"/>
    </operation>
    <operation name="contingency_stats">
      <documentation>This programs takes as input a contingency table, and calculates various     matching statistics between the rows and columns. The description of these statistics can be found in Brohee and van Helden (2006).</documentation>
      <input name="ContingencyStatsRequest" message="tns:contingency_statsRequest"/>
      <output name="ContingencyStatsResponse" message="tns:contingency_statsResponse"/>
    </operation>
    <operation name="contingency_table">
      <documentation> Create a contingency table from a two-column file.</documentation>
      <input name="ContingencyTableRequest" message="tns:contingency_tableRequest"/>
      <output name="ContingencyTableResponse" message="tns:contingency_tableResponse"/>
    </operation>
    <operation name="matrix_scan">
      <documentation>Scan sequences with one or several position-specific scoring matrices (PSSM) to identify instances of the corresponding motifs(putative sites). This program supports a variety of background models (Bernoulli, Markov chains of any order).</documentation>
      <input name="MatrixScanRequest" message="tns:matrix_scanRequest"/>
      <output name="MatrixScanResponse" message="tns:matrix_scanResponse"/>
    </operation>
    <operation name="convert_matrix">
      <documentation>Performs inter-conversions between various formats of position-specific scoring matrices (PSSM). The program also performs a statistical analysis of the original matrix to provide different position-specific scores (weight, frequencies, information contents), general statistics (E-value, total information content), and synthetic descriptions (consensus).</documentation>
      <input name="ConvertMatrixRequest" message="tns:convert_matrixRequest"/>
      <output name="ConvertMatrixResponse" message="tns:convert_matrixResponse"/>
    </operation>
    <operation name="matrix_distrib">
      <documentation>Returns the theoretical distribution of matrix weight within the defined background model.</documentation>
      <input name="MatrixDistribRequest" message="tns:matrix_distribRequest"/>
      <output name="MatrixDistribResponse" message="tns:matrix_distribResponse"/>
    </operation>
    <operation name="random_seq">
      <documentation>Generates random sequences.</documentation>
      <input name="RandomSequenceRequest" message="tns:random_seqRequest"/>
      <output name="RandomSequenceResponse" message="tns:random_seqResponse"/>
    </operation>

    <!-- NeA TOOLS PORTTYPES -->
    <operation name="convert_graph">
      <documentation>Convert graphs between different formats</documentation>
      <input name="ConvertGraphRequest" message="tns:convert_graphRequest"/>
      <output name="ConvertGraphResponse" message="tns:convert_graphResponse"/>         
    </operation>
    <operation name="alter_graph">
      <documentation>Alter a graph either by adding or removing edges or nodes</documentation>
      <input name="AlterGraphRequest" message="tns:alter_graphRequest"/>
      <output name="AlterGraphResponse" message="tns:alter_graphResponse"/>         
    </operation>
    <operation name="graph_cliques">
      <documentation>Find all cliques in a graph</documentation>
      <input name="GraphCliquesRequest" message="tns:graph_cliquesRequest"/>
      <output name="GraphCliquesResponse" message="tns:graph_cliquesResponse"/>         
    </operation>
    <operation name="display_graph">
      <documentation>Produces the figure of a graph</documentation>
      <input name="DisplayGraphRequest" message="tns:display_graphRequest"/>
      <output name="DisplayGraphResponse" message="tns:display_graphResponse"/>         
    </operation>
    <operation name="draw_heatmap">
      <documentation>Produces the figure of a heatmap</documentation>
      <input name="DrawHeatmapRequest" message="tns:draw_heatmapRequest"/>
      <output name="DrawHeatmapResponse" message="tns:draw_heatmapResponse"/>         
    </operation>
    <operation name="compare_graphs">
      <documentation>Computes the union / difference or intersection of two graphs</documentation>
      <input name="CompareGraphsRequest" message="tns:compare_graphsRequest"/>
      <output name="CompareGraphsResponse" message="tns:compare_graphsResponse"/>         
    </operation>
    <operation name="graph_node_degree">
      <documentation>Calculates the in / out / global degree for a selection of seed nodes</documentation>
      <input name="GraphNodeDegreeRequest" message="tns:graph_node_degreeRequest"/>
      <output name="GraphNodeDegreeResponse" message="tns:graph_node_degreeResponse"/>         
    </operation>
    <operation name="graph_topology">
      <documentation>Calculate the node degree, the closeness and the betweenness of each node and specifies if this node is a seed or a target node.</documentation>
      <input name="GraphTopologyRequest" message="tns:graph_topologyRequest"/>
      <output name="GraphTopologyResponse" message="tns:graph_topologyResponse"/>         
    </operation>
    <operation name="graph_cluster_membership">
      <documentation>Map a clustering result onto a graph, and compute the membership degree between each node and each cluster, on the basis of egdes linking this node to the cluster.</documentation>
      <input name="GraphClusterMembershipRequest" message="tns:graph_cluster_membershipRequest"/>
      <output name="GraphClusterMembershipResponse" message="tns:graph_cluster_membershipResponse"/>         
    </operation>
    <operation name="random_graph">
      <documentation>Generate random graphs either from scratch of from an existing graph using different randomization models</documentation>
      <input name="RandomGraphRequest" message="tns:random_graphRequest"/>
      <output name="RandomGraphResponse" message="tns:random_graphResponse"/>         
    </operation>	
    <operation name="graph_get_clusters">
      <documentation>Compares a graph with a classification/clustering file.</documentation>
      <input name="GraphGetClustersRequest" message="tns:graph_get_clustersRequest"/>
      <output name="GraphGetClustersResponse" message="tns:graph_get_clustersResponse"/>         
    </operation>
    <operation name="graph_neighbours">
      <documentation>Find the neihbours up to a certain distance of a collection of seed nodes</documentation>
      <input name="GraphNeighboursRequest" message="tns:graph_neighboursRequest"/>
      <output name="GraphNeighboursResponse" message="tns:graph_neighboursResponse"/>         
    </operation>
    <operation name="mcl">
      <documentation>Clustering via Stijn van Dongen MCL algorithm</documentation>
      <input name="MCLRequest" message="tns:mclRequest"/>
      <output name="MCLResponse" message="tns:mclResponse"/>         
    </operation>
    <operation name="rnsc">
      <documentation>Clustering via Andrew King RNSC algorithm</documentation>
      <input name="RNSCRequest" message="tns:rnscRequest"/>
      <output name="RNSCResponse" message="tns:rnscResponse"/>
    </operation>

    <!-- GENERAL UTILITY TOOLS PORTTYPES -->
    <operation name="monitor">
      <documentation>Monitoring the status of a job</documentation>
      <input name="MonitorRequest" message="tns:monitorRequest"/>
      <output name="MonitorResponse" message="tns:monitorResponse"/>         
    </operation>
    <operation name="get_result">
      <documentation>Get result of a job</documentation>
      <input name="GetResultRequest" message="tns:get_resultRequest"/>
      <output name="GetResultResponse" message="tns:get_resultResponse"/>         
    </operation>
  </portType>

  <binding name="RSATWSBinding" type="tns:RSATWSPortType">
    <!-- RSA TOOLS BINDINGS -->
    <soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
    <operation name="retrieve_seq">
      <soap:operation soapAction=""/>
      <input name="RetrieveSequenceRequest">
        <soap:body use="literal" />
      </input>
      <output name="RetrieveSequenceResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="retrieve_seq_multigenome">
      <soap:operation soapAction=""/>
      <input name="RetrieveSequenceMultigenomeRequest">
        <soap:body use="literal" />
      </input>
      <output name="RetrieveSequenceMultigenomeResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="retrieve_ensembl_seq">
      <soap:operation soapAction=""/>
      <input name="RetrieveEnsemblSequenceRequest">
        <soap:body use="literal" />
      </input>
      <output name="RetrieveEnsemblSequenceResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="purge_seq">
      <soap:operation soapAction=""/>
      <input  name="PurgeSequenceRequest">
        <soap:body use="literal" />
      </input>
      <output name="PurgeSequenceResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="oligo_analysis">
      <soap:operation soapAction=""/>
      <input name="OligoAnalysisRequest">
        <soap:body use="literal" />
      </input>
      <output name="OligoAnalysisResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="dyad_analysis">
      <soap:operation soapAction=""/>
      <input name="DyadAnalysisRequest">
        <soap:body use="literal" />
      </input>
      <output name="DyadAnalysisResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="pattern_assembly">
      <soap:operation soapAction=""/>
      <input name="PatternAssemblyRequest">
        <soap:body use="literal" />
      </input>
      <output name="PatternAssemblyResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="dna_pattern">
      <soap:operation soapAction=""/>
      <input name="DnaPatternRequest">
        <soap:body use="literal" />
      </input>
      <output name="DnaPatternResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="convert_features">
      <soap:operation soapAction=""/>
      <input name="ConvertFeaturesRequest">
        <soap:body use="literal" />
      </input>
      <output name="ConvertFeaturesResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="feature_map">
      <soap:operation soapAction=""/>
      <input name="FeatureMapRequest">
        <soap:body use="literal" />
      </input>
      <output name="FeatureMapResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="footprint_discovery">
      <soap:operation soapAction=""/>
      <input name="FootprintDiscoveryRequest">
        <soap:body use="literal" />
      </input>
      <output name="FootprintDiscoveryResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="get_orthologs">
      <soap:operation soapAction=""/>
      <input name="GetOrthologsRequest">
        <soap:body use="literal" />
      </input>
      <output name="GetOrthologsResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="infer_operon">
      <soap:operation soapAction=""/>
      <input name="InferOperonRequest">
        <soap:body use="literal" />
      </input>
      <output name="InferOperonResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="gene_info">
      <soap:operation soapAction=""/>
      <input name="GeneInfoRequest">
        <soap:body use="literal" />
      </input>
      <output name="GeneInfoResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="supported_organisms">
      <soap:operation soapAction=""/>
      <input name="SupportedOrganismsRequest">
        <soap:body use="literal" />
      </input>
      <output name="SupportedOrganismsResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="text_to_html">
      <soap:operation soapAction=""/>
      <input name="TextToHtmlRequest">
        <soap:body use="literal" />
      </input>
      <output name="TextToHtmlResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="parse_psi_xml">
      <soap:operation soapAction=""/>
      <input name="parsepsixmlRequest">
        <soap:body use="literal" />
      </input>
      <output name="parsepsixmlResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="roc_stats">
      <soap:operation soapAction=""/>
      <input name="RocStatsRequest">
        <soap:body use="literal" />
      </input>
      <output name="RocStatsResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="classfreq">
      <soap:operation soapAction=""/>
      <input name="ClassFreqRequest">
        <soap:body use="literal" />
      </input>
      <output name="ClassFreqResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="xygraph">
      <soap:operation soapAction=""/>
      <input name="XYGraphRequest">
        <soap:body use="literal" />
      </input>
      <output name="XYGraphResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="convert_seq">
      <soap:operation soapAction=""/>
      <input name="ConvertSeqRequest">
        <soap:body use="literal" />
      </input>
      <output name="ConvertSeqResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="compare_classes">
      <soap:operation soapAction=""/>
      <input name="CompareClassesRequest">
        <soap:body use="literal" />
      </input>
      <output name="CompareClassesResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="convert_classes">
      <soap:operation soapAction=""/>
      <input name="ConvertClassesRequest">
        <soap:body use="literal" />
      </input>
      <output name="ConvertClassesResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="contingency_stats">
      <soap:operation soapAction=""/>
      <input name="ContingencyStatsRequest">
        <soap:body use="literal" />
      </input>
      <output name="ContingencyStatsResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="contingency_table">
      <soap:operation soapAction=""/>
      <input name="ContingencyTableRequest">
        <soap:body use="literal" />
      </input>
      <output name="ContingencyTableResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="matrix_scan">
      <soap:operation soapAction=""/>
      <input name="MatrixScanRequest">
        <soap:body use="literal" />
      </input>
      <output name="MatrixScanResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="convert_matrix">
      <soap:operation soapAction=""/>
      <input name="ConvertMatrixRequest">
        <soap:body use="literal" />
      </input>
      <output name="ConvertMatrixResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="matrix_distrib">
      <soap:operation soapAction=""/>
      <input name="MatrixDistribRequest">
        <soap:body use="literal" />
      </input>
      <output name="MatrixDistribResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="random_seq">
      <soap:operation soapAction=""/>
      <input name="RandomSequenceRequest">
        <soap:body use="literal" />
      </input>
      <output name="RandomSequenceResponse">
        <soap:body use="literal" />
      </output>
    </operation>

    <!-- NeA TOOLS BINDINGS -->
    <operation name="convert_graph">
      <soap:operation soapAction=""/>
      <input name="ConvertGraphRequest">
        <soap:body use="literal" />
      </input>
      <output name="ConvertGraphResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="alter_graph">
      <soap:operation soapAction=""/>
      <input name="AlterGraphRequest">
        <soap:body use="literal" />
      </input>
      <output name="AlterGraphResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="graph_cliques">
      <soap:operation soapAction=""/>
      <input name="GraphCliquesRequest">
        <soap:body use="literal" />
      </input>
      <output name="GraphCliquesResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="display_graph">
      <soap:operation soapAction=""/>
      <input name="DisplayGraphRequest">
        <soap:body use="literal" />
      </input>
      <output name="DisplayGraphResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="draw_heatmap">
      <soap:operation soapAction=""/>
      <input name="DrawHeatmapRequest">
        <soap:body use="literal" />
      </input>
      <output name="DrawHeatmapResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="compare_graphs">
      <soap:operation soapAction=""/>
      <input name="CompareGraphsRequest">
        <soap:body use="literal" />
      </input>
      <output name="CompareGraphsResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="graph_neighbours">
      <soap:operation soapAction=""/>
      <input name="GraphNeighboursRequest">
        <soap:body use="literal" />
      </input>
      <output name="GraphNeighboursResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="mcl">
      <soap:operation soapAction=""/>
      <input name="MCLRequest">
        <soap:body use="literal" />
      </input>
      <output name="MCLResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="rnsc">
      <soap:operation soapAction=""/>
      <input name="RNSCRequest">
        <soap:body use="literal" />
      </input>
      <output name="RNSCResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="graph_node_degree">
      <soap:operation soapAction=""/>
      <input name="GraphNodeDegreeRequest">
        <soap:body use="literal" />
      </input>
      <output name="GraphNodeDegreeResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="graph_topology">
      <soap:operation soapAction=""/>
      <input name="GraphTopologyRequest">
        <soap:body use="literal" />
      </input>
      <output name="GraphTopologyResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="graph_cluster_membership">
      <soap:operation soapAction=""/>
      <input name="GraphClusterMembershipRequest">
        <soap:body use="literal" />
      </input>
      <output name="GraphClusterMembershipResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="graph_get_clusters">
      <soap:operation soapAction=""/>
      <input name="GraphGetClustersRequest">
        <soap:body use="literal" />
      </input>
      <output name="GraphGetClustersResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="random_graph">
      <soap:operation soapAction=""/>
      <input name="RandomGraphRequest">
        <soap:body use="literal" />
      </input>
      <output name="RandomGraphResponse">
        <soap:body use="literal" />
      </output>
    </operation>

    <!-- GENERAL UTILITY TOOLS BINDINGS -->
    <operation name="monitor">
      <soap:operation soapAction=""/>
      <input name="MonitorRequest">
        <soap:body use="literal" />
      </input>
      <output name="MonitorResponse">
        <soap:body use="literal" />
      </output>
    </operation>
    <operation name="get_result">
      <soap:operation soapAction=""/>
      <input name="GetResultRequest">
        <soap:body use="literal" />
      </input>
      <output name="GetResultResponse">
        <soap:body use="literal" />
      </output>
    </operation>
  </binding>

  <service name="RSATWebServices">
    <documentation>Web services for the Regulatory Sequence Analysis Tools (RSAT). Tools developed by Jacques van Helden (jvanheld@bigre.ulb.ac.be), SOAP/WSDL interface developed by Olivier Sand (oly@bigre.ulb.ac.be).</documentation>
    <port name="RSATWSPortType" binding="tns:RSATWSBinding">
      <soap:address location="http://rsat.ulb.ac.be/rsat/web_services/RSATWS.cgi"/>
      <!-- <soap:address location="http://127.0.0.1/rsat/web_services/RSATWS.cgi"/> -->
    </port>
  </service>
</definitions>
